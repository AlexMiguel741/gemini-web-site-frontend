<!DOCTYPE html>
<html>
<head>
    <title>Test Calendar Logic - Real iCal Data</title>
</head>
<body>
    <h1>Calendar Test - Real iCal Data</h1>
    <div id="status">Loading...</div>
    <div id="output"></div>

    <script>
        const icalUrl = 'https://ical.booking.com/v1/export/t/e95dd962-d17c-4d29-8b5b-1e8235c1fe19.ics';
        const status = document.getElementById('status');
        const output = document.getElementById('output');

        // CORS proxy options (same as in icalService.ts)
        const proxies = [
            `https://api.allorigins.win/get?url=${encodeURIComponent(icalUrl)}`,
            `https://cors-anywhere.herokuapp.com/${icalUrl}`,
            `https://thingproxy.freeboard.io/fetch/${icalUrl}`
        ];

        async function fetchIcalData() {
            status.textContent = 'Fetching iCal data...';
            console.log('Starting iCal fetch for URL:', icalUrl);

            let icsText = null;

            // Try each proxy
            for (const proxyUrl of proxies) {
                try {
                    status.textContent = `Trying proxy: ${proxyUrl.substring(0, 30)}...`;
                    console.log('Trying proxy:', proxyUrl);

                    const response = await fetch(proxyUrl, {
                        headers: {
                            'Accept': 'text/calendar, application/json',
                        }
                    });

                    console.log('Response status:', response.status, response.statusText);

                    if (response.ok) {
                        const data = await response.json();
                        console.log('Response data:', data);

                        if (data && data.contents) {
                            // Handle base64 encoded data URL
                            if (data.contents.startsWith('data:text/calendar;base64,')) {
                                const base64Data = data.contents.split(',')[1];
                                icsText = atob(base64Data);
                                console.log('Decoded base64 iCal content, length:', icsText.length);
                            } else {
                                icsText = data.contents;
                                console.log('Got plain iCal content, length:', icsText.length);
                            }
                            status.textContent = 'Successfully fetched iCal data!';
                            break;
                        } else {
                            console.warn('Response missing contents field');
                        }
                    } else {
                        console.warn('Response not ok:', response.status);
                    }
                } catch (error) {
                    console.error('Proxy failed:', error);
                    status.innerHTML += '<br>Error: ' + error.message;
                    continue;
                }
            }

            if (!icsText) {
                status.textContent = 'Failed to fetch iCal data from all proxies';
                console.error('All proxies failed');
                return [];
            }

            status.textContent = 'Parsing iCal data...';
            const ranges = parseIcsString(icsText);
            console.log('Parsed ranges:', ranges);
            return ranges;
        }

        function parseIcsString(icsText) {
            const ranges = [];
            const lines = icsText.split(/\r?\n/);

            let currentStart = null;
            let currentEnd = null;

            for (const line of lines) {
                const cleanLine = line.trim();
                if (cleanLine.startsWith('BEGIN:VEVENT')) {
                    currentStart = null;
                    currentEnd = null;
                } else if (cleanLine.startsWith('DTSTART')) {
                    currentStart = extractDate(cleanLine);
                } else if (cleanLine.startsWith('DTEND')) {
                    currentEnd = extractDate(cleanLine);
                } else if (cleanLine.startsWith('END:VEVENT')) {
                    if (currentStart && currentEnd) {
                        ranges.push({ start: currentStart, end: currentEnd });
                    }
                }
            }

            return ranges;
        }

        function extractDate(line) {
            const parts = line.split(':');
            let dateStr = parts[parts.length - 1];
            if (!dateStr) return null;

            // Remove any parameters
            dateStr = dateStr.split(';').pop() || dateStr;

            // Handle different formats
            if (dateStr.length === 8) {
                // YYYYMMDD format
                const year = parseInt(dateStr.substring(0, 4));
                const month = parseInt(dateStr.substring(4, 6)) - 1;
                const day = parseInt(dateStr.substring(6, 8));
                const date = new Date(year, month, day);
                return isNaN(date.getTime()) ? null : date;
            } else if (dateStr.includes('T')) {
                // ISO format
                try {
                    const isoStr = dateStr.replace(/(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})Z?/, '$1-$2-$3T$4:$5:$6Z');
                    const date = new Date(isoStr);
                    return isNaN(date.getTime()) ? null : date;
                } catch {
                    return null;
                }
            }

            // Try parsing as ISO string directly
            try {
                const date = new Date(dateStr);
                return isNaN(date.getTime()) ? null : date;
            } catch {
                console.warn('Could not parse date:', dateStr);
                return null;
            }
        }

        async function testCalendar() {
            const realRanges = await fetchIcalData();

            if (realRanges.length === 0) {
                status.textContent = 'No booking data found';
                return;
            }

            status.textContent = `Found ${realRanges.length} booking ranges`;

            // Test December 2025 dates
            for (let day = 1; day <= 31; day++) {
                const checkDate = new Date(2025, 11, day);
                checkDate.setHours(0, 0, 0, 0);

                const isBooked = realRanges.some(range => {
                    const startDate = new Date(range.start);
                    startDate.setHours(0, 0, 0, 0);
                    const endDate = new Date(range.end);
                    endDate.setHours(0, 0, 0, 0);

                    return checkDate >= startDate && checkDate < endDate;
                });

                output.innerHTML += `<p>Day ${day} (${checkDate.toDateString()}): <strong>${isBooked ? 'BOOKED' : 'AVAILABLE'}</strong></p>`;
            }

            // Also show the booking ranges
            output.innerHTML += '<h2>Booking Ranges:</h2>';
            realRanges.forEach((range, i) => {
                output.innerHTML += `<p>${i + 1}. ${range.start.toDateString()} to ${range.end.toDateString()}</p>`;
            });
        }

        testCalendar();
    </script>
</body>
</html>
